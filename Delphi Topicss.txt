Dictionary
	https://docwiki.embarcadero.com/Libraries/Athens/en/System.Generics.Collections.TDictionary
	https://docwiki.embarcadero.com/Libraries/Athens/en/System.Generics.Collections.TObjectDictionary
	https://docwiki.embarcadero.com/Libraries/Athens/en/System.Generics.Collections.TDictionaryOwnerships

FireDAC
	https://docwiki.embarcadero.com/Libraries/Alexandria/en/FireDAC.Stan.Option.TFDFetchOptions
	https://docwiki.embarcadero.com/RADStudio//Alexandria/en/Working_with_Commands_(FireDAC)
	
DLLs
	https://docwiki.embarcadero.com/RADStudio/Sydney/en/Libraries_and_Packages_Index
	https://docwiki.embarcadero.com/RADStudio/Sydney/en/Libraries_and_Packages_(Delphi)
	https://docwiki.embarcadero.com/RADStudio/Sydney/en/Writing_Dynamically_Loaded_Libraries
	
	
Packages
	https://docwiki.embarcadero.com/RADStudio/Sydney/en/Packages_(Delphi)
	
	

========================================================================================================================================
Delphi XE to Delphi 10.4.2 Sydney:
========================================================================================================================================

Delphi 2010
	Support for Windows 7
	Touch screen and gestures
	Source Code Audits and Metrics

Delphi XE
	Regular Expression library
	Command line audits, metrics, and document generation
Delphi XE3
	FMX (FireMonkey)
Delphi XE4
	FireDAC universal data access components
	Interbase IBLite
	Mobile form designer
	
Delphi 10
	Windows Server 2019 support
	Android 11, macOS11, iOS 14 support
	TNumberBox


========================================================================================================================================
About:
========================================================================================================================================
Completed B.Tech from GMRIT in 1st class with distinction.
Started career with Efftronics as a R&D software engineer.
	I was assigned to railway signalining based project as team member with team of 5.
	We followed waterfall model to deliver the project and I involved in all phases of SDLC.
	
Then I moved to TCS as a software engineer.
    In TCS, I was assigned to health care project. And in this project, we followed scrum to provide deliverables.
    After 3 years, I promoted to IT Analysist and I started managing 4 resources.
	Same year, our team was nominated as best team for delivering project related ICC codes.
	
After worked for 7 years in TCS, I moved to cognizant.
	In cognizant, I was assigned to oil and gas project as Sr. delphi developer with 3 more resources under me.
	Here, we migrated this project from Delphi 7 to Delphi 10.4.2 in 8 months.
	After that, we did some enhancements and 100+ bug fixes(CARs).
	Later, we implemented 10+ security related features.
	
Mainly I worked with Delphi, Ms SQL Server, and MySQL.
And also I woked in Python, PySpark, Perl and with GCP services as part of RDIs.


========================================================================================================================================
Delphi 7 to Delphi 10.4.2 Sydney migration:
========================================================================================================================================
1. Migrated database connection from BDE to FireDAC components
	Took corresponding components
	All mapped properties
	Complex inline queries moved to SPs
	
2. DateSeparator: Char;
   TimeSeparator: Char;
   ListSeparator: Char;            //These variables are declared in SysUtils unit old versions of Delphi. 
   ShortDateFormat: string;        //A new record TFormatSettings was created and moved all these for thread safety.
   LongDateFormat: string;         //We should use these TFormatSettings.TimeSeparator
   TimeAMString: string;	// GetLocaleFormatSettings		
   TimePMString: string;
3. TChart.View3DOptions.ZoomText is Boolean   ---> Now, ztNo, ztNormal, ztAuto
4. Steema software components are separate. now in VclTee package. Could not compile used unit - Series, TeeProcs,  TeEngine, Chart, TeeComma, TeeEdit  --> VclTee
5. PAnsiChar to PWideChar/PChar
   Windows.MessageBox method requires parameter of type PWideChar
6. Incompatible parameter list
   GridDBTableView  --> GetContentStyle: Type of one of the parameters of this event is changed from out to var. Parameter name Astyle.
   WriteProcessMemory method requires parameter of type  NativeUInt. Before it was Word type.
7. Read-only -- cannot be assigned

 For character array, Count := SizeOf(Buffer);  wrong  => Count := Length(Buffer);
 
 Count := Length(Buffer);             wrong     =>      Count := Length(Buffer) * SizeOf(Char); // <<-- Specify buffer size in bytes
 FillChar(Buffer, Count, 0);							FillChar(Buffer, Count, 0);
  
 Count := Length(Buf1);							=> 		Count := Length(Buf1) * SizeOf(Char); // <<-- Specify buffer size in bytes
 Move(Buf1, Buf2, Count);

 GetProcAddress should always use PAnsiChar, since there is no analogous wide function in the Windows API.
 @RegisterProc := GetProcAddress(Handle, PAnsiChar(AnsiString(ProcName))); 
 
 AppendStr is deprecated and is hard-coded to use AnsiString
 AppendStr(String1, String2);   				=>		String1 := String1 + String2;
  

========================================================================================================================================
Secure Coding Standards:
========================================================================================================================================
0. Secure Authentication
	Use multi-factor auth
	Dont store passwords in plain text format. Use salted hashes
	
1. Input validation:
	Validate input from user, file, database, or other external sources
    To vaoid SQL injection, command injection, buffer overflow

2. Avoid hardcoding sensitive information:
	Passwords, API keys or other sensitive information in our code
	
3. Parameterized queries 
	SQL injection
	
4. DLL hijacking, Secure storage of sensitive information, spying sensitive information

5. Secure communication
	Sensitive information over network using secure protocols like SSL/TLS
	Indy with SSL support
	
6. Error handling
	Gracefully handle exceptions
	Avoid displaying detailed error messages to user
	
7. Memory management:
	Safe memory management to avoid memory leaks, buffer overflows
	
8. Broken access control
	User management - Roles and privileges
	Minimal privilage to the user for any file or resource:
	
9. ASLR/DEP - 
	Address Space Layout Randomization
	Data Execution Prevention
	
	

========================================================================================================================================
Threading:
========================================================================================================================================
uses System.Classes;

type
  MyThread1 = class(TThread)
  private
    FProgressBar: TProgressBar;
	FPauseEvent: TEvent;
  protected
    procedure Execute; override;
  public 
	constructor Create(PB: TProgressBar); override;
  end;
  
  contructor MyThread1.Create(PB: TProgressBar);
  begin
	inherited Create(False);
	
	FProgressBar := PB;
	FreeOnTerminate := True;
	Priority := tpNormal;
	FPauseEvent := TEvent.Create(nil, True, False, '');
  end;
  
  procedure MyThread1.Execute;
  begin
    NameThreadForDebugging('MySampleThread');
	
	for i:= 0 to 100 do
	begin
		if Terminated then
			Exit;
		
		if bPaused then //To pause the thread, set bPaused to True
			FPauseEvent.WaitFor(INFINITE);
			
		Sleep(1000);
		Synchronize(
			procedure 
			begin
				FProgressBar.Position := i;
			end;
		);
	end;
  end;
  
  TObj := MyThread1.Create(TProgressBar1);
  
  
========================================================================================================================================
Critical Section:
========================================================================================================================================
	uses System.SyncObjs

	CS: TCriticalSection

	CS := TCriticalSection.Create(nil);
	
	begin
		FC.Acquire;
		try
			Inc(Counter);
		finally
			FC.Release;
		end;
	end;


========================================================================================================================================
Mutex (Mutual Exclusion): Synchronization primitive that ensures only one thread can access shared resource 
========================================================================================================================================
	uses System.SyncObjs
	
	mutexObj: TMutex;
	mutexObj := TMutex.Create(nil, False, 'MyMutex');
	
	begin
		mutexObj.Acquire;
		try
			Inc(Counter);
		finally
			mutexObj.Release;
		end;
	end;
	
	
	MyMutexObj := TMutex.Create(nil, False, 'SLGMutex');

    if MyMutexObj.WaitFor(0) = wrTimeout then
    begin
        BringToFront( AppWindowTitle );
    end

========================================================================================================================================
Semaphore:
========================================================================================================================================
	uses System.SyncObjs
	
	sempObj: TSemaphore;
	sempObj := TSemaphore.Create(nil, 2, MaxInt, 'MySemaphore');  //Allows 2 threads max.
	
	//binarySempObj := TSemaphore.Create(nil, 1, 1, 'MyBinarySemaphore');  //Allows only 1 threads max.
	
	begin
		sempObj.Acquire;
		try
			Inc(Counter);
		finally
			sempObj.Release;
		end;
	end; 
	
	
========================================================================================================================================
Multi-processing:
========================================================================================================================================
var Process: TProcess;
begin
	Process := TProcess.Create(nil);
	try
		Process.Executable := 'notepad';
		Process.Execute;
	finally
		Process.Free;
	end;
end;
	
  
========================================================================================================================================
IPC (Inter-process communication):
========================================================================================================================================
Windows Messages:
----------------------------------------------------------------------------------------------------------------------------------------
SendMessage(Handle, WM_USER+1, 0, LPARAM('Hello'));


procedure TForm1.WndProc(Message: TMessage);
begin
  if Message.Msg = WM_USER+1 then
  begin
    ShowMessage(PChar(Message.LPARAM));
  end;
  inherited WndProc(Message);
end;


Named Pipes:
----------------------------------------------------------------------------------------------------------------------------------------

var
	ServerPipe: TNamedPipeServer;
	Hnd: THandle;
	Data: string;
begin
	ServerPipe := TNamedPipeServer.Create(nil);
	try
	  ServerPipe.PipeName := '\\.\pipe\MyPipe';
	  ServerPipe.Active := True;
	  Hnd := ServerPipe.Handle;
	  
	  if WaitForNamedPipe(PChar(ServerPipe.PipeName), 5000) then
	  begin  
		WriteFile(Hnd, 'Hello', 5, nil, nil);
	  end;
	  
	finally
	  ServerPipe.Free;
	end;
end;
------------------------------------------------------------------

var
	ClientPipe: TNamedPipeClient;
	Hnd: THandle;
	Buf: array [0..255] of Char;
begin
	ClentPipe := TNamedPipeClient.Create(nil);
	try
	  ClientPipe.PipeName := '\\.\pipe\MyPipe';
	  ClentPipe.Connect(5000);
	  Hnd := ClentPipe.Handle;
	  ReadFile(Hnd, Buf, 5, nil, nil);
	  
	  ShowMessage(Buf);
	finally
	  ClientPipe.Free;
	end;
end;


Sockets:
----------------------------------------------------------------------------------------------------------------------------------------
Socket connections can be divided into three basic types, which reflect how the connection was initiated and what the local socket is connected to. 
  --> Client connections: First, the client socket must describe the server socket to which it wishes to connect. 
                          The client socket then looks up the server socket and, when it locates the server, requests a connection. 
						  The server socket may not complete the connection right away. 
						  Server sockets maintain a queue of client requests, and complete connections as they find time. 
						  When the server socket accepts the client connection, it sends the client socket a full description of the server socket to which it is connecting, and the connection is completed by the client.
  --> Listening connections: Server sockets do not locate clients. Instead, they form passive “half connections” that listen for client requests. 
                             Server sockets associate a queue with their listening connections; the queue records client connection requests as they come in. 
							 When the server socket accepts a client connection request, it forms a new socket to connect to the client, so that the listening connection can remain open to accept other client requests.
  --> Server connections: Server connections are formed by server sockets when a listening socket accepts a client request. 
						  A description of the server socket that completes the connection to the client is sent to the client when the server accepts the connection. 
						  The connection is established when the client socket receives this description and completes the connection.



uses System.Win.ScktComp;

procedure TForm8.btn1Click(Sender: TObject);
var Server: TServerSocket;
begin
  Server := TServerSocket.Create(nil);
  Server.Port := 5234;
  Server.OnClientCOnnect := SendData;
  Server.Active := True;
end;
------------------------------------------------------------------

procedure TForm8.btn2Click(Sender: TObject);
var Client: TClientSocket;
begin
  Client := TClientSocket.Create(nil);
  Client.Port := 5234;
  Client.Host := 'localhost';
  Client.Active := True;
  ShowMessage(Client.Socket.ReceiveText);
end;
------------------------------------------------------------------

procedure TForm8.SendData(Sender: TObject; Socket: TCustomWinSocket);
begin
  socket.SendText('Hello');
end;


Message Queues:
----------------------------------------------------------------------------------------------------------------------------------------

var
	Hnd: THandle;
begin
	Hnd := CreateMailSlot('\\.\mailslot\MySlot1', 0, MAILSLOT_WAIT_FOREVER, nil);
	WriteFile(Hnd, 'Hello', 5, nil, nil);
	CloseHandle(Hnd);
end;
------------------------------------------------------------------

var 
	Hnd: THandle;
	Buf: arra [0..255] of Char;
begin
	Hnd:= CreateFile('\\.\mailslot\MySlot1', GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0);
	ReadFile(Hnd, Buf, 5, nil, nil);
	CloseHandle(Hnd);
	ShowMessage(Buf);
end;


========================================================================================================================================
Interfaces: 
========================================================================================================================================
An object interface, or simply interface, defines methods that can be implemented by a class. Interfaces are declared
like classes, but cannot be directly instantiated and do not have their own method definitions. Rather, it is the
responsibility of any class that supports an interface to provide implementations for the interface's methods. A
variable of an interface type can reference an object whose class implements that interface; however, only methods
declared in the interface can be called using such a variable

The memberList can include only methods and properties. Fields are not allowed in interfaces.
Since an interface has no fields, property read and write specifiers must be methods.
All members of an interface are public. Visibility specifiers and storage specifiers are not allowed. (But an array
property can be declared as default.)
Interfaces have no constructors or destructors. They cannot be instantiated, except through classes that
implement their methods.
Methods cannot be declared as virtual, dynamic, abstract, or override. Since interfaces do not implement their 
own methods, these designations have no meaning.

type interfaceName = interface (ancestorInterface)
 ['{GUID}']
 memberList
end;

If no ancestor is specified, the interface is a direct
descendant of IInterface, which is defined in the System unit and is the ultimate ancestor of all other interfaces.
On Win32, IInterface declares three methods: QueryInterface, _AddRef, and _Release.

QueryInterface provides the means to obtain a reference to the different interfaces that an object supports.
_AddRef and _Release provide lifetime memory management for interface references. The easiest way to
implement these methods is to derive the implementing class from the System unit's TInterfacedObject.

Properties declared in an interface are accessible only through expressions of the interface type; they cannot be
accessed through class-type variables. Moreover, interface properties are visible only within programs where the
interface is compiled.
In an interface, property read and write specifiers must be methods, since fields are not available

An interface declaration that ends with the reserved word interface and a semicolon, without specifying an ancestor,
GUID, or member list, is a forward declaration. A forward declaration must be resolved by a defining declaration of
the same interface within the same type declaration section. In other words, between a forward declaration and its
defining declaration, nothing can occur except other type declarations.

Once an interface has been declared, it must be implemented in a class before it can be used. The interfaces
implemented by a class are specified in the class's declaration, after the name of the class's ancestor

type className = class (ancestorClass, interface1, ..., interfacen)
 memberList
end;

You can override the default name-based mappings by including method resolution clauses in a class declaration.
When a class implements two or more interfaces that have identically named methods, use method resolution
clauses to resolve the naming conflicts.

A method resolution clause has the form
	procedure interface.interfaceMethod = implementingMethod;


Both abstract class and interfaces are used to define contracts or blueprints for classes.
-- all methods are abstract -- it contains both abstract methods and concrete methods
-- class can implement multiple interfaces -- class can inherit from only one abstract class
-- used to acheive multiple inheritance and defines common behaviour across unrelated classes -- used to define common functionality across subclasses but leave specific implemtation

IShape = interface
	procedure Draw;          //No implementations
	function Area: double;   //No implementations
end;

TRectangle = class(TInterfacedObject, IShape)
	procedure Draw;						//Implemented here
	function Area: double;				//Implemented here
end;

------------------------------------------------------------------

TShape = class abstract
	procedure Draw; virtual; abstract;  //No implementations
	function Area: double; virtual;		//Implemented here
end;

TRectangle = class(TShape)
	procedure Draw; override;			//Implemented here
end;





========================================================================================================================================
INI File Read/Write: 
========================================================================================================================================
var File: TINIFile;
begin
	File := TINIFile.Create('1.ini');
	try
		File.WriteString('Section', 'Key', 'Value');
	finally
		File.Free;
	end;
end;
------------------------------------------------------------------

var File: TINIFile;
begin
	File := TINIFile.Create('1.ini');
	try
		File.ReadString('Section', 'Key', 'Default-Value');
	finally
		File.Free;
	end;
end;

ReadBool/WriteBool
ReadDateTime/WriteDateTime
ReadInteger/WriteInteger

========================================================================================================================================
Text File Read/Write: 
========================================================================================================================================
var
	myFile : TextFile;
	text   : string;
begin
	// Try to open the Test.txt file for writing to
	AssignFile(myFile, 'Test.txt');
	ReWrite(myFile);

	// Write a couple of well known words to this file
	WriteLn(myFile, 'Hello World');

	// Close the file
	CloseFile(myFile);

	// Reopen the file for reading
	Reset(myFile);

	// Display the file contents
	while not Eof(myFile) do
	begin
		ReadLn(myFile, text);
		ShowMessage(text);
	end;

	// Close the file for the last time
	CloseFile(myFile);
end;


========================================================================================================================================
Registry Read/Write: 
========================================================================================================================================
var reg: TRegistry;

reg := TRegistry.Create(KEY_READ);
reg.RootKey := HKEY_LOCAL_MACHINE;

if reg.KeyExists('Software\MyCompanyName\MyApplication\') then
openResult := reg.OpenKey('Software\MyCompanyName\MyApplication\',False);
reg.ReadDateTime(Now);
reg.ReadString('Default');
------------------------------------------------------------------

reg.Access := KEY_WRITE;
openResult := reg.OpenKey('Software\MyCompanyName\MyApplication\',True);
reg.WriteDateTime('Creation\ Date', today);
reg.WriteString('Licenced\ To', 'MySurname\ MyFirstName');
------------------------------------------------------------------

reg.DeleteKey('Software\MyCompanyName\MyApplication');
reg.DeleteKey('Software\MyCompanyName');

reg.CloseKey();
reg.Free;


========================================================================================================================================
XML Read/Write: 
========================================================================================================================================
var
  xDoc: IXMLDocument;
  xElement, xData, xText, xRoot, xPerson: IXMLNode;
begin
  xDoc := TXMLDocument.Create(nil);
  xDoc.Active := True;

  xRoot := xDoc.AddChild('People');
  xRoot.Attributes['Desc'] := 'Person Details';

  xPerson := xRoot.AddChild('Person');
  xPerson.AddChild('Name').Text := 'Hari';
  xPerson.AddChild('Age').Text := '32';
  xPerson.AddChild('Gender').Text := 'Male';

  xElement := xDoc.CreateNode('ThisIsTheDocumentElement', ntElement, '');
  xElement.Attributes['attrName'] := 'attrValue';
  xDoc.DocumentElement.ChildNodes.Add(xElement);

  xElement := xRoot.AddChild('ThisElementHasText', -1);
  xElement.Text := 'Inner text.';

  xData := xDoc.CreateNode('any characters here', ntCData, '');
  xRoot.ChildNodes.Add(xData);

  xText := xDoc.CreateNode('This is a text node.', ntText, '');
  xRoot.ChildNodes.Add(xText);

  
  xDoc.SaveToFile('D:\1.xml');
end;
------------------------------------------------------------------

var
  xDoc: IXMLDocument;
  xNodeElement, xNode: IXMLNode;
  LAttrValue: string;
  I: Integer;
begin
  xDoc := TXMLDocument.Create(nil);
  xDoc.LoadFromFile('D:\1.xml');

  xNodeElement := xDoc.ChildNodes.FindNode('People');

  if (xNodeElement <> nil) then
  begin
    if (xNodeElement.HasAttribute('Desc')) then
    begin
      LAttrValue := xNodeElement.Attributes['Desc'];
    end;

    for I := 0 to xNodeElement.ChildNodes.Count - 1 do
    begin
      xNode := xNodeElement.ChildNodes.Get(I);

      Showmessage('Node name: ' + xNode.NodeName);

      if xNode.NodeType = ntText then
      begin
        Showmessage('Node Text: ' + xNode.Text);
      end;

      if xNode.IsTextElement then
      begin
        Showmessage('Node Text: ' + xNode.Text);
      end;
    end;
  end;
end;


var
  LDocument: IXMLDocument;
begin
  LDocument := TXMLDocument.Create(nil);

  LDocument.ParseOptions := LDocument.ParseOptions + [poPreserveWhiteSpace];

  //LDocument.ParseOptions := LDocument.ParseOptions - [poPreserveWhiteSpace];

  LDocument.LoadFromXML
    ('<CloudType>       <Cirrocumulus />       </CloudType>');
  
  Writeln(LDocument.XML.Text);
end;

========================================================================================================================================
JSON Read/Write: 
========================================================================================================================================

https://docwiki.embarcadero.com/RADStudio/Alexandria/en/JSON


========================================================================================================================================
Stream Read/Write: 
========================================================================================================================================

The Read method reads a specified number of bytes from the stream, starting at its current Position, into a buffer. 
Read then advances the current position by the number of bytes actually transferred. The prototype for Read is
	function Read(var Buffer; Count: Longint): Longint;
The Write method writes Count bytes from a buffer to the stream, starting at the current Position. The prototype for Write is:
	function Write(const Buffer; Count: Longint): Longint;
The counterpart procedures are ReadBuffer and WriteBuffer which, unlike Read and Write, do not return the number of bytes read or written. 
These procedures are useful in cases where the number of bytes is known and required, for example when reading in structures. 
ReadBuffer and WriteBuffer raise an exception (EReadError and EWriteError) if the byte count can not be matched exactly. 
This is in contrast to the Read and Write methods, which can return a byte count that differs from the requested value. 
The prototypes for ReadBuffer and WriteBuffer are:
	procedure ReadBuffer(var Buffer; Count: Longint);
	procedure WriteBuffer(const Buffer; Count: Longint);
TStream defines specialized methods, ReadComponent and WriteComponent, for reading and writing components. 
You can use them in your applications as a way to save components and their properties when you create or alter them at run time.



========================================================================================================================================
COM (Component Object Model): 
========================================================================================================================================
It is technology used for creating binary software components that can interact with each other. COM Object creation is language independent. 

COM allows components written in one language can communicate with components written in other languages.
Components can be reused in multiple applications. --> Reusability
COM supports both local and distributed architectures.
COM supports versioning i.e. allows different versions of components coexist on same machine without conflicts.

COM Interface - A COM object provides an interface for each set of related methods and properties.
COM Server - A module, either an EXE, or DLL, that contains the code for a COM object. 
			 Object implementations reside in servers. A COM object implements one or more interfaces.
COM Client - The code that calls the interfaces to get the requested services from the server. 
             Clients know what they want to get from the server (through the interface); 
			 clients do not know the internals of how the server provides the services


All COM objects must support the fundamental interface, called IUnknown, a typedef to the base interface type IInterface. IUnknown contains the following routines:
  --> QueryInterface: Provides pointers to other interfaces that the object supports.
  --> AddRef and Release: Simple reference counting methods that keep track of the object’s lifetime so that an object can delete itself when the client no longer needs its service.
  
A COM object is an instance of a CoClass, which is a class that implements one or more COM interfaces. 
CoClasses are instantiated by a special type of object called a class factory. 
Whenever an object’s services are requested by a client, a class factory creates an object instance for that particular client. 
Typically, if another client requests the object’s services, the class factory creates another object instance to service the second client

With COM, a client does not need to know where an object resides, it simply makes a call to an object’s interface. COM performs the necessary steps to make the call.
  --> In-process server: A library (DLL) running in the same process space as the client
  --> Out-of-process server (or local server): Another application (EXE) running in a different process space but on the same machine as the client
  --> Remote Server: A DLL or another application running on a different machine from that of the client
  
COM itself has extended its core functionality by defining specialized sets of interfaces for specific purposes. The following lists some of the services COM extensions currently provide.
  --> Automation Servers: Automation refers to the ability of an application to control the objects in another application programmatically. 
      Automation servers are the objects that can be controlled by other executables at runtime. 
  --> ActiveX controls are specialized in-process servers, typically intended for embedding in a client application. 
      The controls offer both design and runtime behaviors as well as events
  --> Active Server Pages are scripts that generate HTML pages. The scripting language includes constructs for creating and running Automation objects. 
      That is, the Active Server Page acts as an Automation controller.
  --> Active Documents: Objects that support linking and embedding, drag-and-drop, visual editing, and in-place activation. 
      Word documents and Excel spreadsheets are examples of Active Documents.
  --> Transactional objects that include additional support for responding to large numbers of clients. 
      This includes features such as just-in-time activation, transactions, resource pooling, and security services. 
  --> Type libraries: A collection of static data structures, often saved as a resource, that provides detailed type information about an object and its interfaces. 
      Clients of Automation servers, ActiveX controls, and transactional objects expect type information to be available.
	  

========================================================================================================================================
VCL Hierarchy:
========================================================================================================================================
	  
TObject:
TObject encapsulates the fundamental behavior common to all classes in the component library by introducing methods that provide:
• The ability to respond when object instances are created or destroyed.
• Class type and instance information on an object, and runtime type information (RTTI) about its published properties.
• Support for handling messages 
They are transitory. This means that these classes do not have a method to save the state that they are in prior to destruction; they are not persistent


TPersistent:
Because of their persistence, objects from this branch can appear at design time. However, they can’t exist independently. Rather, they implement properties for 
components. Properties are only loaded and saved with a form if they have an owner. The owner must be some component. TPersistent introduces the GetOwner
method, which lets the Form Designer determine the owner of the object.
EG: TBrush, TFont, TPen, TBitmap, TIcon, TClipboard, TStringList, TCollection


TComponent:
The TComponent branch contains classes that descend from TComponent but not TControl. Objects in this branch are components that you can manipulate on forms at 
design time but which do not appear to the user at runtime. They are persistent objects that can do the following:
• Appear on the Component palette and be changed on the form.
• Own and manage other components.
• Load and save themselves
Eg: TActionList, TMainMenu, TOpenDialog, TSaveDialog, TFontDialog, TFindDialog, TColorDialog, TScreen, TTimer


TControl:
Whereas TComponent defines behavior for all components, TControl defines behavior for all visual controls.
The TControl branch consists of components that descend from TControl but not TWinControl (TWidgetControl in CLX applications). 
Classes in this branch are controls: visual objects that the user can see and manipulate at runtime. 
All controls have properties, methods, and events in common that relate to how the control looks, such as its position, the cursor associated with the control’s window, methods to 
paint or move the control, and events to respond to mouse actions. 
Controls in this branch, however, can never receive keyboard input.


TGraphicControl:
Classes in the TControl branch often called graphic controls, because they all descend from TGraphicControl, which is an immediate descendant of TControl. 
Although these controls appear to the user at runtime, graphic controls do not have their own underlying window or widget. 
Instead, they use their parent’s window or widget. It is because of this limitation that graphic controls cant receive keyboard input or act as a parent to other controls. 
However, because they do not have their own window or widget, graphic controls use fewer system resources


TWidgetControl:
Unlike graphic controls, controls in this branch have their own associated window or widget. Because of this, they are sometimes called windowed controls or widget controls. 
• Can receive focus while an application is running, which means they can receive keyboard input from the application user. In comparison, graphic controls can only display data and respond to the mouse.
• Can be the parent of one or more child controls.
• Have a handle, or unique identifier, that allows them to access the underlying window or widget.


TObject
TPersistent
TComponent
TControl
TScrollingWinControl
TCustomForm
TForm
	  
TObject
TPersistent
TComponent
TControl
TWinControl
TButtonControl
TCustomButton
TButton

TObject
TPersistent
TComponent
TControl
TGraphicControl
TCustomLabel
TLabel

TObject
TPersistent
TComponent
TTimer

TObject
Exception

TObject
TPersistent
TComponent
TDatasource

TObject
TPersistent
TComponent
TCustomConnection
TADOConnection 					TSQLConnection

TObject
TPersistent
TComponent
TDataset
TCustomADODataset				TCustomSQLDataSet
TADOQuery/TADOTable				TSQLQuery/TSQLTable

========================================================================================================================================
Exception Handling: 
========================================================================================================================================
try
	SetFieldValue(dataField, userValue);
except
on E: EIntegerRange do ShowMessage(Format('Expected value between %d and %d, but got %d', E.Min, E.Max, E.Value));
on EZeroDivide do Value := MAXINT;
on EIntOverflow do Value := 0;
on EIntUnderflow do Value := 0;
end;

try
	SetFieldValue(dataField, userValue);
except 
	on EFOpenError do ShowMessage('EFOpenError Raised');
else
	ShowMessage('Exception Raised');
end;

try
 { statements that may raise an exception}
finally
 { statements that are called even if there is an exception in the try block}
end;


Raising Exceptions:
type
	EPasswordInvalid = class(Exception);

if Password <> CorrectPassword then
	raise EPasswordInvalid.Create('Incorrect password entered');


Reraising Exceptions:
try
	{ statements }
	try
		{ special statements }
	except on ESomething do
		begin
			{ handling for only the special statements }
			raise;{ reraise the exception }
		end;
	end;
except on ESomething do 
	...;{ handling you want in all cases }
end;


Default Exception:
If your application code does not catch and handle the exceptions that are raised, the exceptions are ultimately caught and handled by the HandleException method of the global Application object. 
For all exceptions (Except EAbort), HandleException calls the OnException event handler, if one exists. 
If there is no OnException event handler (and the exception is not EAbort), HandleException displays a message box with the error message associated with the exception.

There are certain circumstances where HandleException does not get called. 
-- Exceptions that occur before or after the execution of the application’s Run method are not caught and handled by HandleException. 
-- When you write a callback function or a library (.dll or shared object) with functions that can be called by an external application, exceptions can escape the Application object. 
To prevent exceptions from escaping in this manner, you can insert your own call to the HandleException method:
	try
		{ special statements }
	except on Exception do
		begin
			Application.HandleException(Self);{ call HandleException }
		end;
	end;
	
Silent Exceptions:
	Silent exceptions are useful when you don't intend to report an exception to the user, but you want to abort an operation. 
	Aborting an operation is similar to using the Break or Exit procedures to break out of a block, but can break out of several nested levels of blocks.
	Silent exceptions all descend from the standard exception type EAbort. 
	The default exception handler for VCL applications displays the error-message dialog box for all exceptions that reach it except those descended from EAbort.

	Abort automatically raises an EAbort exception, which breaks out of the current operation without displaying an error message.
	There is a distinction between Abort and abort. abort kills the application.

for I := 1 to 10 do{ loop ten times }
	for J := 1 to 10 do {loop ten times }
	begin
		ListBox1.Items.Add(IntToStr(I) + IntToStr(J));
		if I = 7 then Abort;{ abort after the 7th iteration of outer loop} --> Abort causes the flow of execution to break out of both the inner and outer loops, not just the inner loop.
	end;

Defining Exceptions:
type
	EMyException = class(Exception);
	



==============================================================================================================================================================================================	
Free Vs FreeAndNil:
==============================================================================================================================================================================================
Free:
if Self <> nil then
    Destroy;
	
FreeAndNil:
var
  Temp: TObject;
begin
  Temp := Obj;
  TObject(Pointer(@Obj)^) := nil;
  Temp.Free;
end;




OOP
Inheritance
Abstract Classes
Virtual Vs Dynamic
Override Vs Overload Vs Hiding



========================================================================================================================================
Connecting to Database: 
========================================================================================================================================
Borland Database Engine (BDE) 	TDatabase
ActiveX Data Objects (ADO) 		TADOConnection
dbExpress 						TSQLConnection
InterBase Express 				TIBDatabase
FireDAC							TFDConnection

For BDE-enabled datasets, you specify an implicit connection using the DatabaseName property. For ADO-based datasets, you use the ConnectionString property.
Call the Open method. or Set the Connected property to True. --> Calling the Open method sets Connected to True. 
When a connection component is not connected to a server and an application attempts to open one of its associated datasets, the dataset automatically calls the connection component’s Open method.
When you set Connected to True, the connection component first generates a BeforeConnect event, where you can perform any initialization.
After the BeforeConnect event, the connection component may display a default login dialog.
Once the connection is open, the connection component generates an AfterConnect event.

Once a connection is established, it is maintained as long as there is at least one active dataset using it. 
When there are no more active datasets, the connection component drops the connection. 
Some connection components surface a KeepConnection property that allows the connection to remain open even if all the datasets that use it are closed. 
If KeepConnection is True, the connection is maintained.

Set the Connected property to False. Call the Close method. --> Calling Close sets Connected to False.
When Connected is set to False, the connection component generates a BeforeDisconnect event, where you can perform any cleanup before the connection closes.
Finally, the connection component generates an AfterDisconnect event.


procedure TForm1.SQLConnectionBeforeConnect(Sender: TObject);
begin
	with Sender as TSQLConnection do
	begin
		if LoginPrompt = False then
		begin
			Params.Values['User_Name'] := 'SYSDBA';
			Params.Values['Password'] := Decrypt(Params.Values['Password']);
		end;
	end;
end;



A transaction is a group of actions that must all be carried out successfully on one or more tables in a database before they are committed (made permanent). 
If one of the actions in the group fails, then all actions are rolled back (undone). 
By using transactions, you ensure that the database is not left in an inconsistent state when a problem occurs completing one of the actions that make up the transaction. 

Level := ADOConnection1.BeginTrans;
if not Database1.InTransaction then
	Database1.StartTransaction;
SQLConnection1.StartTransaction(TD);

ADOConnection1.CommitTrans; / .RollbackTrans;
Database1.Commit; / .Rollback
SQLConnection1.Comit; / Rollback;
IBDatabase1.DefaultTransaction.Commit; / .DefaultTransaction.Rollback;

Transaction isolation level determines how a transaction interacts with other simultaneous transactions when they work with the same tables.
	DirtyRead: When the isolation level is DirtyRead, your transaction sees all changes made by other transactions, even if they have not been committed. 
	ReadCommitted: When the isolation level is ReadCommitted, only committed changes made by other transactions are visible.
	RepeatableRead: When the isolation level is RepeatableRead, your transaction is guaranteed to see a consistent state of the database data. 
					Your transaction sees a single snapshot of the data. 
					It cannot see any subsequent changes to data by other simultaneous transactions, even if they are committed.
					
					
All database connection components except TIBDatabase let you execute SQL statements on the associated server by calling the Execute method. 
Although Execute can return a cursor when the statement is a SELECT statement, this use is not recommended. 
The preferred method for executing statements that return data is to use a dataset.
The Execute method is very convenient for executing simple SQL statements that do not return any records.
	DDL statements, which operate on or create a database’s metadata, such as CREATE INDEX, ALTER TABLE, and DROP DOMAIN. 
	Some DML SQL statements also do not return a result set: INSERT, DELETE, and UPDATE.

All database connection components can retrieve lists of metadata on the database server:
	MyDBConnection.GetTableNames(ListBox1.Items, False);   //False-No system tables
	MyDBConnection.GetFieldNames('Employee', ListBox1.Items);
	MyDBConnection.GetProcedureNames(ListBox1.Items);
	SQLConnection1.GetIndexNames('Employee', ListBox1.Items);
	SQLConnection1.GetProcedureParams('GetInterestRate', List1);
	

https://docwiki.embarcadero.com/RADStudio/Sydney/en/Overview_of_ADO_Components

TADOTable  -- Sorting the data using Indexed Fields:

	var
	  I: Integer;
	  ListOfIndexFields: array[0 to 20} of string;
	begin
	with CustomersTable do
	  begin
	  for I := 0 to IndexFieldCount - 1 do
		 ListOfIndexFields[I] := IndexFields[I].FieldName;
	  end;
	end;

	Use the IndexName property to cause an index to be active. Once active, an index determines the order of records in the dataset.
	You can obtain a list of available indexes by calling the GetIndexNames method.
		CustomersTable.IndexName := 'CustDescending';

	If there is no defined index that implements the sort order you want, you can create a pseudo-index using the IndexFieldNames property.
		PhoneTable.IndexFieldNames := 'LastName;FirstName';


TADOTable  -- Searching the data using Indexed Fields:

	SetKey - Clears the search key buffer and puts the table into dsSetKey
	EditKey - Preserves the current contents of the search key buffer and puts the dataset into dsSetKey state

	GotoKey - Searches for the first record in a dataset that exactly matches the search criteria, and moves the cursor to that record if one is found.
	GotoNearest - Searches on string-based fields for the closest match to a record based on partial key values, and moves the cursor to that record.
	
	FindKey - Combines the SetKey and GotoKey methods in a single method.
	FindNearest - Combines the SetKey and GotoNearest methods in a single method.
	
	procedure TSearchDemo.SearchExactClick(Sender: TObject);
	begin
	  ClientDataSet1.SetKey;
	  ClientDataSet1.Fields[0].AsString := Edit1.Text;
	  if not ClientDataSet1.GotoKey then
		ShowMessage('Record not found');
	end;
	

	Table1.SetKey;
	Table1.Fields[0].AsString := 'Sm';
	Table1.GotoNearest;


TADOTable - Filtering the data

	A range is a set of contiguously indexed records that fall between specified boundary values. 
	For example, in an employee database indexed on last name, you might apply a range to display all employees whose last names are greater than "Jones" and less than "Smith"

	with Customers do
	begin
	  SetRangeStart;
	  FieldByName('CustNo').AsString := StartVal.Text;
	  SetRangeEnd;
	  if (Length(EndVal.Text) > 0) then
		FieldByName('CustNo').AsString := EndVal.Text;
	  ApplyRange;
	end;
	
	The CancelRange method ends application of a range and restores access to the full dataset. 
		MyTable.CancelRange;
		
	A filter, on the other hand, is any set of records that share specified data points, regardless of indexing. 
	For example, you might filter an employee database to display all employees who live in California and who have worked for the company for five or more years.	
	
	Create a filter.
	Set filter options for string-based filter tests, if necessary.
	Set the Filtered property to True.
	
		There are two ways to create a filter for a dataset:
			Set the Filter property --> Filter is especially useful for creating and applying filters at run time.
			Or Write an OnFilterRecord event -  filter can be complex and variable

	For example, the following statements set up a filter that ignores case when comparing values in the State field:
		FilterOptions := [foCaseInsensitive];   //One more option - foNoPartialCompare
		Filter := 'State = ' + QuotedStr('CA');
		
		
TADOTable - Master/Details relationship

		Table type datasets can be linked into master/detail relationships. 
		When you set up a master/detail relationship, you link two datasets so that all the records of one (the detail) always correspond to the single current record in the other (the master).
		
		Set the MasterSource property of OrdersTable to "dsCustomers". This links the CUSTOMER table (the master table) to the ORDERS table (the detail table).
		Double-click the MasterFields property value box in the Object Inspector to invoke the Field Link Designer to set the following properties:
			In the Available Indexes field, choose CustemerId to link the two tables by the CustemerId field.
			Select CustemerId in both the Detail Fields and Master Fields field lists.
			Click the Add button to add this join condition. In the Joined Fields list,"CustemerId -> CustemerId" appears.
			Choose OK to commit your selections and exit the Field Link Designer.
			
			
TADOTable - Sync Tables
	If you have two or more datasets that represent the same database table but do not share a data source component, then each dataset has its own view on the data and its own current record. 
		CustomerTableOne.GotoCurrent(CustomerTableTwo);
		
TADOTable - Read/Write
	When the table opens, you can check the CanModify property to ascertain whether the underlying database allows users to edit the data in the table. 
	If CanModify is False, the application cannot write to the database. 
	If CanModify is True, your application can write to the database provided the table's ReadOnly property is False.
		
		
	
		var
			TableFound: Boolean;
		begin
			with TTable.Create(nil) do // create a temporary TTable component
			begin
				 try
				   { set properties of the temporary TTable component }
				   Active := False;
				   DatabaseName := 'DBDEMOS';
				   TableName := Edit1.Text;
				   TableType := ttDefault;
				   { define fields for the new table }
				   FieldDefs.Clear;
				   with FieldDefs.AddFieldDef do begin
					 Name := 'First';
					 DataType := ftString;
					 Size := 20;
					 Required := False;
				   end;
				   with FieldDefs.AddFieldDef do begin
					 Name := 'Second';
					 DataType := ftString;
					 Size := 30;
					 Required := False;
				   end;
				   { define indexes for the new table }
				   IndexDefs.Clear;
				   with IndexDefs.AddIndexDef do begin
					 Name := '';
					 Fields := 'First';
					 Options := [ixPrimary];
				   end;
				   TableFound := Exists; // check whether the table already exists
				   if TableFound then
					 if MessageDlg('Overwrite existing table ' + Edit1.Text + '?',
						  mtConfirmation, mbYesNoCancel, 0) = mrYes then
					   TableFound := False;
				   if not TableFound then
					 CreateTable; // create the table
				 finally
				   Free; // destroy the temporary TTable when done
				 end;
			end;
		end;
		
		
		To delete a table at run time, call the dataset's DeleteTable method
			CustomersTable.DeleteTable;


	
	
	
==============================================================================================================================================================================================	
Dataset Vs ClientDataSet:
==============================================================================================================================================================================================
TDataSet:
	All dataset objects are descend from TDataSet, and they inherit data fields, properties, events, and methods from this class.
	TDataSet is a virtualized dataset, meaning that many of its properties and methods are virtual or abstract. 

TClientDataset:
	It is a concrete class that inherited from TDataset.
	It is specially designed for in-memory dataset.
	It can store data from various sources like databases, XML files, or other datasets and work with them locally without requiring a live database connection.
	
	.Data - Provides access to the  in-memory data
	.IndexFieldNames - Specifies the field names used for indexing the dataset.
	.PacketRecords - Specifies the no. of records to fetch from the server in each packet.
	.Filter := 'Salary >50000'
	.Filtered - True/False
	.Aggregates.Add;
	.Aggregates[0].Expression := 'Sum(Salary)'; 
	
	
	.CreateDataset - Create an empty in-memory dataset structure
	.LoadFromFile - Loads data from a file
	.SaveToFile - Saves data to a file
	.ApplyUpdates - Applies changes made to the in-memory dataset to the underlying database.
	
	
TDataSetProvider:
	It provides data from a dataset and resolves updates to that dataset or its database server.
	TDataSetProvider packages data from a dataset and passes it in one or more transportable data packets to the client dataset or XML broker. 
	The client dataset reconstructs the data in the data packet to create a local, in-memory copy for user access. 
	When user access is complete, the client dataset repackages any changed data and sends the updates back to the provider. 
	The provider applies the updates to the database or source dataset.



==============================================================================================================================================================================================	
Memory Management:
==============================================================================================================================================================================================
	The memory manager manages all dynamic memory allocations and deallocations in an application. 
	The memory manager reserves memory from the OS in 1Mb sections of address space, and commits memory as required in 16K increments.
		Application code resides in code segment.
		Global variables and constants are allocated on the application data segment and persist for the duration of the program. 
		Local variables, arguments, return values reside in an application's stack. 
			The values are controlled through the $MINSTACKSIZE and $MAXSTACKSIZE compiler directives
		Dynamic variables created with the GetMem or New procedure are heap-allocated and persist until they are deallocated with FreeMem or Dispose.
		Long strings, wide strings, dynamic arrays, variants, and interfaces are heap-allocated, but their memory is managed automatically
	
	The New, Dispose, GetMem, FreeMem, AllocMem, and ReallocMem standard procedures use the memory manager, and all objects and long strings are allocated through the memory manager.
		procedure GetMem(var P: Pointer; Size: Integer);
			GetMem allocates a block of the given Size on the heap, and returns the address of this memory in the P parameter. 
			The bytes of the allocated buffer are not set to zero. 
			To dispose of the buffer, use FreeMem. 
			If there is not enough memory available to allocate the block, an EOutOfMemory exception is raised.
		function AllocMem(Size: NativeInt): Pointer;
			If the memory block must be initialized with zero, you can use AllocMem. Remaining - Same as above
		procedure ReallocMem(var P: Pointer; Size: Integer);
			If you have to change the size of this memory block, call ReallocMem, passing the existing memory block pointer in P and the revised block size in Size. 
			If ReallocMem cannot expand the memory block pointed to by P, it frees the referenced memory and copies the values to the newly allocated memory that is returned. 
			The content of the newly allocated memory is not set to zero.
		procedure FreeMem(var P: Pointer; [ Size: Integer]); overload;
			Use this procedure to dispose of a memory block obtained with GetMem.
			The Size parameter specifies the size, in bytes, of the dynamic variable to dispose of. 
				If specified, it must be exactly the number of bytes previously allocated to that variable by GetMem.
		procedure New(var X: Pointer);
			In Delphi code, the New procedure creates a new dynamic variable (say record) and sets a pointer variable to point to it. 
			The size of the allocated memory block corresponds to the size of the type that P points to. 
			The newly created variable can be referenced as P^
		procedure Dispose(var P: Pointer);
			Dispose releases the memory allocated for a pointer variable allocated using System.New.
			
			
		The memory manager in use is determined by the target platform/compiler of your application.
			Platform    	Compiler    	Memory Manager name
			Win32			DCC32			FastMM (GETMEM.inc)
			Win64			DCC64			FastMM (GETMEM.inc)
			
		FastMM Memory Manager is optimized for applications that allocate large numbers of small- to medium-sized blocks.	
		
		When you allocate memory that you don't expect to free, you can register it with the Memory Manager. 
		The Memory Manager adds it to a list of areas to ignore when it checks for memory leaks. 
			Identify the pointer to the memory area you don't expect to free.
			Pass the pointer to RegisterExpectedMemoryLeak.
		When you unregister a memory location, the Memory Manager removes it from its list of expected memory leaks.
			Identify the pointer to the memory area you want to unregister.
			Pass the pointer to UnregisterExpectedMemoryLeak.
			
		The Memory Manager provides two procedures that allow the application to monitor its own memory usage and the state of the process's address space.
		To monitor memory usage for your application:
			Call the procedure GetMemoryManagerState.
		To get a map of the memory address space for a process
			Call the procedure GetMemoryMap.
			
		If a DLL exports routines that pass long strings or dynamic arrays as parameters or function results, then the DLL and its client applications (or DLLs) must all share the same memory manager. 
		The same is true if one application or DLL allocates memory with System.New or System.GetMem which is deallocated by a call to System.Dispose or System.FreeMem in another module. 
		There are two mutually exclusive methods through which the Memory Manager can be shared between an application and its libraries: ShareMem and SimpleShareMem.
		To use ShareMem:
			List ShareMem as the first unit in the program and library uses clause. 
			Your modules will become dependant on the external BORLNDMM.DLL library, allowing them to share dynamically allocated memory.
			Deploy BORLNDMM.DLL with your application or DLL that uses ShareMem. 
			When an application or DLL uses ShareMem, its memory manager is replaced by the memory manager in BORLNDMM.DLL.
		To use SimpleShareMem:
			List SimpleShareMem as the first unit in the program and library uses clause in each of your modules. 
			The module that is initialized first will be the module that will share its memory manager. 
			All modules initialized after that will use the memory manager of the first module.
		
		To set the minimum block alignment for the Memory Manager
			Use the function GetMinimumBlockAlignment to fetch the current minimum block alignment.
			Select the appropriate memory block alignment for your application. Available block alignments are 8-byte (System.mba8Byte) and 16-byte (System.mba16Byte).
			To change the memory block alignment, use the procedure SetMinimumBlockAlignment.
		
		To report memory leaks on shutdown
			Set the global variable System.ReportMemoryLeaksOnShutdown to True.
			When the Memory Manager shuts down, it scans the memory pool and report all unregistered memory leaks in a message dialog.
		
		The Memory Manager is a shared resource, and when many threads in the application attempt to perform a Memory Manager operation at the same time, 
		one or more threads might have to wait for a pending operation in another thread to complete before it can continue. This situation is called thread contention. 
		To never sleep on thread contention in the Memory Manager
			Set the global variable System.NeverSleepOnMMThreadContention to True.
			When a thread contention occurs inside the Memory Manager, it will wait inside a loop until the contention is resolved.
			
			
==============================================================================================================================================================================================		
Datasnap (Delphi technology):
==============================================================================================================================================================================================
DataSnap allows the development of multi-tier applications, most notably multi-tier database applications.
DataSnap offers the possibility to create Client-Server applications that communicate through the Internet, the local network, or the local host.
The main feature of DataSnap is the ability of the Client application to invoke methods that are implemented on a Server. 
DataSnap automatically generates the necessary interface for the Client to communicate with the Server, containing the prototypes of the Server methods.
DataSnap provides a way for the Client to safely communicate with the Server, using a secured transfer of JSON content over TCP/IP or HTTP.
DataSnap offers the possibility to asynchronously notify all the Client applications about changes made to the Server, so that Clients can take appropriate actions. 
The callback does not require Clients to invoke any of the Server methods.

Server:
	TDSServer: The logical heart of the DataSnap server application.
		.AutoStart property -> True or use .Start/.Stop methods
	TDSTCPServerTransport: Component implements a multithreaded TCP server listening for incoming client connections on multiple threads.
		.Server property -> DSServer1
		.Port property -> N (Default 211)
	TDSServerClass: Component represents a server class. The DataSnap server automatically creates and destroys instances of server classes. 
					The instancing of a server class is controlled by the LifeCycle property of the TDSServerClass component.         
		.Server property -> DSServer1
		.LifeCycle property -> Server, Session, and Invocation
			Server - the DataSnap server creates one instance of a server class that is used by all clients connected to the server application.
			Session - the DataSnap server creates one instance of a server class for every connected client.
			Invocation - server class instance is created and destroyed for every method call arriving from a client, and the state of a server class is not preserved between method calls.
		.OnGetClass event -> Define this event as below:
		
		procedure TForm1.DSServerClass1GetClass(DSServerClass: TDSServerClass; var PersistentClass: TPersistentClass);
		begin
			PersistentClass := TMyClass;  //This the class contains the implementation of the server's methods you want to use in the client application 
		end;
							
Client:
	TSQLConnection 			
		.Driver property -> Datasnap
		.LoginPrompt property -> False
		.CommunicationProtocol -> TCP/IP or HTTP
		.Connected property -> True
		
		Creating the interface that contains the prototype of all functions implemented on the server:
			Run the server application and minimize it.
			In the Design tab, set the Connected property of the TSQLConnection component to True.
			Right-click the TSQLConnection component on the Client form and click Generate DataSnap client classes in the context menu. A new unit is added to your client project.
			Save the unit and Call the desired methods in the client application.

==============================================================================================================================================================================================	
Pointer and Ponter Types:
==============================================================================================================================================================================================
	https://docwiki.embarcadero.com/RADStudio/Sydney/en/Pointers_and_Pointer_Types_(Delphi)



==============================================================================================================================================================================================	
Service Application:
==============================================================================================================================================================================================
